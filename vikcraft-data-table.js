/*
 * VikCraft Interactive Data Table JavaScript
 * Version 2.3.0 (Complete and Final)
 *
 * This script creates a feature-rich, interactive data table.
 * It supports both client-side and server-side data processing.
 */
class VikCraftDataTable {
    constructor(containerSelector, userConfig) {
        this.container = document.querySelector(containerSelector);
        if (!this.container) {
            console.error(`VikCraftDataTable Error: Container "${containerSelector}" not found.`);
            return;
        }

        const defaultConfig = {
            data: [],
            columns: [],
            columnGroups: [],
            actions: [],
            enableCheckboxes: true,
            enableSearch: true,
            enableColumnFilter: true,
            enablePagination: true,
            enablePageLength: true,
            enableColumnResize: true,
            enableGrouping: true,
            enableEditing: false, // <-- NEW: Default to false
            defaultPageLength: 10,
            pageLengthOptions: [5, 10, 25, 50, 100],
            defaultGroupBy: null,
            theme: 'default',

            // --- Server-Side Setup ---
            serverSide: false,
            ajax: null,
            method: 'GET', // Can be 'GET' or 'POST'
            customFilters: {},
            onCheckboxChange: null,
            onSelectAll: null,
            onCellEdit: null, // <-- NEW: Callback for cell edits

            // --- NEW: Excel Export Configuration ---
            enableExcelExport: false,
            excelExportConfig: {
                title: 'Data Report',
                subtitle: 'Generated by VikCraft Data Table',
                filename: 'report.xlsx'
            }
        };
        this.config = { ...defaultConfig, ...userConfig };

        // --- NEW: Deep merge the excel config ---
        if (userConfig.excelExportConfig) {
            this.config.excelExportConfig = { ...defaultConfig.excelExportConfig, ...userConfig.excelExportConfig };
        }

        this.state = {
            currentPage: 1,
            rowsPerPage: this.config.defaultPageLength,
            sortColumn: null,
            sortDirection: 'asc',
            globalFilter: '',
            columnFilters: {},
            groupBy: this.config.defaultGroupBy,
            collapsedGroups: new Set(),
            totalRecords: 0,
        };

        this.filterOperators = {
            string: ['contains', 'does not contain', 'equals', 'not equal', 'begins with', 'ends with', 'blank', 'not blank'],
            number: ['=', '!=', '>', '>=', '<', '<=', 'blank', 'not blank'],
        };

        this.init();
    }

    // --- 1. INITIALIZATION ---
    init() {
        this.container.classList.add('vikcraft-data-table-wrapper');
        this.setTheme(this.config.theme);
        this.buildInitialHTML();
        this.getDomReferences();
        this.createHeader();
        this.addEventListeners();

        if (this.state.groupBy) {
            this.updateGroupByUI();
        }

        if (this.config.serverSide) {
            this.fetchData();
        } else {
            this.render();
        }
    }

    buildInitialHTML() {
        this.container.innerHTML = `
            ${this.config.enableGrouping ? `<div class="group-by-container"><span class="group-by-placeholder">Drag a column here to group</span></div>` : ''}
            <div class="table-controls">
                <div class="controls-left">
                    ${this.config.enablePageLength ? `<div class="page-length-container"><label>Show:</label><select class="gdt-page-length">${this.config.pageLengthOptions.map(opt => `<option value="${opt}" ${opt === this.config.defaultPageLength ? 'selected' : ''}>${opt}</option>`).join('')}</select></div>` : ''}
                    
                    ${this.config.enableExcelExport ? `<button class="gdt-excel-export-button">Export to Excel</button>` : ''}
                </div>
                <div class="controls-right">
                    ${this.config.enableSearch ? `<div class="search-container"><input type="text" class="gdt-global-search" placeholder="Search..."></div>` : ''}
                </div>
            </div>
            <div class="table-wrapper"><table class="interactive-table"><thead></thead><tbody></tbody></table></div>
            ${this.config.enablePagination ? `<div class="pagination-controls"><div class="pagination-info"></div><div class="pagination-buttons"></div></div>` : ''}
        `;
    }

    getDomReferences() {
        this.thead = this.container.querySelector('thead');
        this.tbody = this.container.querySelector('tbody');
        if (this.config.enableGrouping) this.groupByContainer = this.container.querySelector('.group-by-container');
        if (this.config.enableSearch) this.globalSearchInput = this.container.querySelector('.gdt-global-search');
        if (this.config.enablePageLength) this.pageLengthSelect = this.container.querySelector('.gdt-page-length');
        // --- NEW: Excel export---
        if (this.config.enableExcelExport) this.excelExportButton = this.container.querySelector('.gdt-excel-export-button');
        if (this.config.enablePagination) {
            this.paginationControlsDiv = this.container.querySelector('.pagination-controls');
            this.paginationInfoDiv = this.container.querySelector('.pagination-info');
            this.paginationButtonsDiv = this.container.querySelector('.pagination-buttons');
        }
    }

    // --- 2. SERVER-SIDE DATA FETCHING ---
    async fetchData() {
        if (!this.config.serverSide || !this.config.ajax) return;

        // Helper function to get the CSRF token from cookies
        const getCsrfToken = () => {
            const csrfCookie = document.cookie.split(';').find(c => c.trim().startsWith('csrftoken='));
            return csrfCookie ? csrfCookie.split('=')[1] : null;
        };

        
        const params = new URLSearchParams({
            page: this.state.currentPage,
            limit: this.state.rowsPerPage,
            globalFilter: this.state.globalFilter || ''
        });
        if (this.state.sortColumn) {
            params.append('sort', this.state.sortColumn);
            params.append('direction', this.state.sortDirection);
        }
        if (this.state.groupBy) {
            params.append('groupBy', this.state.groupBy);
            this.state.collapsedGroups.forEach(g => params.append('collapsed[]', g));
        }
        for (const [key, filter] of Object.entries(this.state.columnFilters)) {
            if (filter.value || ['blank', 'not blank'].includes(filter.operator)) {
                params.append(`filter_${key}`, JSON.stringify(filter));
            }
        }
        // ⬇ CUSTOM FILTERS ⬇
        if (this.config.customFilters) {
            for (const [key, value] of Object.entries(this.config.customFilters)) {
                params.append(key, value);
            }
        }

        const method = this.config.method.toUpperCase();
        let url = this.config.ajax;
        const fetchOptions = {
            method: method,
            headers: {},
            credentials: 'include' // Sends cookies with the request
        };

        if (method === 'POST') {
            // For POST, send params in the body
            fetchOptions.headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
            const csrfToken = getCsrfToken();
            if (csrfToken) {
                fetchOptions.headers['X-CSRFToken'] = csrfToken;
            }
            fetchOptions.body = params;
        } else {
            // For GET, send params in the URL
            url = `${url}?${params.toString()}`;
        }
        
        try {
            const response = await fetch(url, fetchOptions);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const result = await response.json();
            this.tbody.innerHTML = '';
            if (result.isGrouped) {
                this.renderServerGroupedBody(result.data);
                if (this.config.enablePagination) this.paginationControlsDiv.style.display = 'none';
            } else {
                this.state.totalRecords = result.recordsFiltered;
                this.renderBody(result.data);
                if (this.config.enablePagination) {
                    this.paginationControlsDiv.style.display = 'flex';
                    this.renderPagination(this.state.totalRecords);
                }
            }
        } catch (error) {
            console.error("VikCraftDataTable Error: Could not fetch data.", error);
            this.tbody.innerHTML = `<tr><td colspan="99" style="text-align:center;">Error loading data.</td></tr>`;
        }
    }

    // --- 3. EVENT HANDLING ---
    addEventListeners() {
        if (this.config.enableSearch) {
            this.globalSearchInput.addEventListener('keyup', () => {
                this.state.globalFilter = this.globalSearchInput.value;
                this.state.currentPage = 1;
                if (this.config.serverSide) this.fetchData(); else this.render();
            });
        }
        if (this.config.enablePageLength) {
            this.pageLengthSelect.addEventListener('change', () => {
                this.state.rowsPerPage = parseInt(this.pageLengthSelect.value, 10);
                this.state.currentPage = 1;
                if (this.config.serverSide) this.fetchData(); else this.render();
            });
        }
        if (this.config.enableGrouping) {
            this.groupByContainer.addEventListener('dragover', e => {
                e.preventDefault();
                this.groupByContainer.classList.add('drag-over');
            });
            this.groupByContainer.addEventListener('dragleave', () => this.groupByContainer.classList.remove('drag-over'));
            this.groupByContainer.addEventListener('drop', e => {
                e.preventDefault();
                this.groupByContainer.classList.remove('drag-over');
                this.setGroupBy(e.dataTransfer.getData('text/plain'));
            });
        }
        // --- NEW: Add listener for the export button ---
        if (this.config.enableExcelExport) {
            this.excelExportButton.addEventListener('click', () => this.exportToExcel());
        }
    }

    handleSort(key) {
        if (this.state.sortColumn === key) {
            this.state.sortDirection = this.state.sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
            this.state.sortColumn = key;
            this.state.sortDirection = 'asc';
        }
        this.thead.querySelectorAll('th.sortable').forEach(th => th.classList.remove('asc', 'desc'));
        this.thead.querySelector(`th[data-key="${key}"]`).classList.add(this.state.sortDirection);
        if (this.config.serverSide) this.fetchData(); else this.render();
    }

    handleColumnFilterChange(key, part, value) {
        const colType = this.config.columns.find(c => c.key === key)?.type || 'string';
        if (!this.state.columnFilters[key]) {
            this.state.columnFilters[key] = { value: '', operator: this.filterOperators[colType][0] };
        }
        this.state.columnFilters[key][part] = value;
        this.state.currentPage = 1;
        
        if (this.config.serverSide) this.fetchData(); else this.render();
    }
    
    setGroupBy(key) {
        this.state.groupBy = key;
        this.state.collapsedGroups.clear();
        this.updateGroupByUI();
        if (this.config.serverSide) this.fetchData(); else this.render();
    }

    toggleGroup(groupName) {
        if (this.state.collapsedGroups.has(groupName)) {
            this.state.collapsedGroups.delete(groupName);
        } else {
            this.state.collapsedGroups.add(groupName);
        }
        if (this.config.serverSide && this.state.groupBy) {
             this.fetchData(); 
        } else {
             this.render();
        }
    }

    // --- 4. CLIENT-SIDE DATA PREPARATION ---
    getProcessedData() {
        let data = [...this.config.data];

        // --- Global search (already works) ---
        if (this.state.globalFilter) {
            const filterText = this.state.globalFilter.toLowerCase();
            data = data.filter(row => 
                Object.values(row).some(val => 
                    String(val).toLowerCase().includes(filterText)
                )
            );
        }

        // --- Column-Specific Filters (THIS IS THE MISSING LOGIC) ---
        Object.entries(this.state.columnFilters).forEach(([key, filter]) => {
            if (!filter.operator || (filter.operator !== 'blank' && filter.operator !== 'not blank' && !filter.value)) {
                return; // Skip if filter is incomplete
            }

            data = data.filter(row => {
                const rowValue = row[key];
                const filterValue = filter.value;
                const colType = this.config.columns.find(c => c.key === key)?.type || 'string';

                // Handle blank/not blank
                if (filter.operator === 'blank') return rowValue === null || rowValue === '';
                if (filter.operator === 'not blank') return rowValue !== null && rowValue !== '';

                // Handle string comparisons
                if (colType === 'string') {
                    const strRowValue = String(rowValue).toLowerCase();
                    const strFilterValue = String(filterValue).toLowerCase();
                    switch (filter.operator) {
                        case 'contains': return strRowValue.includes(strFilterValue);
                        case 'does not contain': return !strRowValue.includes(strFilterValue);
                        case 'equals': return strRowValue === strFilterValue;
                        case 'not equal': return strRowValue !== strFilterValue;
                        case 'begins with': return strRowValue.startsWith(strFilterValue);
                        case 'ends with': return strRowValue.endsWith(strFilterValue);
                        default: return true;
                    }
                }

                // Handle number comparisons
                if (colType === 'number') {
                    const numRowValue = parseFloat(rowValue);
                    const numFilterValue = parseFloat(filterValue);
                    if (isNaN(numRowValue) || isNaN(numFilterValue)) return false; // Don't compare non-numbers
                    switch (filter.operator) {
                        case '=': return numRowValue === numFilterValue;
                        case '!=': return numRowValue !== numFilterValue;
                        case '>': return numRowValue > numFilterValue;
                        case '>=': return numRowValue >= numFilterValue;
                        case '<': return numRowValue < numFilterValue;
                        case '<=': return numRowValue <= numFilterValue;
                        default: return true;
                    }
                }
                return true;
            });
        });

        // --- Sorting (already works) ---
        if (this.state.sortColumn) {
            data.sort((a, b) => {
                const valA = a[this.state.sortColumn];
                const valB = b[this.state.sortColumn];
                // Handle nulls by treating them as the smallest value
                if (valA === null) return -1;
                if (valB === null) return 1;
                if (valA < valB) return this.state.sortDirection === 'asc' ? -1 : 1;
                if (valA > valB) return this.state.sortDirection === 'asc' ? 1 : -1;
                return 0;
            });
        }
        return data;
    }

    getPaginatedData(data) {
        const start = (this.state.currentPage - 1) * this.state.rowsPerPage;
        return data.slice(start, start + this.state.rowsPerPage);
    }

    // --- 5. RENDERING LOGIC ---
    render() {
        if (this.config.serverSide) return;
        const processedData = this.getProcessedData();
        this.tbody.innerHTML = '';
        if (this.state.groupBy) {
            this.renderClientGroupedBody(processedData);
            if (this.config.enablePagination) this.paginationControlsDiv.style.display = 'none';
        } else {
            const paginatedData = this.getPaginatedData(processedData);
            this.renderBody(paginatedData);
            if (this.config.enablePagination) {
                this.paginationControlsDiv.style.display = 'flex';
                this.renderPagination(processedData.length);
            }
        }
    }

    renderBody(data) {
        this.tbody.innerHTML = '';
        if (!data || data.length === 0) {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = this.config.columns.length + (this.config.enableCheckboxes ? 1 : 0) + (this.config.actions.length > 0 ? 1 : 0);
            td.textContent = 'No matching records found';
            td.style.textAlign = 'center';
            tr.appendChild(td);
            this.tbody.appendChild(tr);
        } else {
            data.forEach(row => this.tbody.appendChild(this.createDataRow(row)));
        }
    }

    renderClientGroupedBody(data) {
        const grouped = data.reduce((acc, row) => {
            const key = row[this.state.groupBy] || 'Uncategorized';
            if (!acc[key]) acc[key] = [];
            acc[key].push(row);
            return acc;
        }, {});
        this.tbody.innerHTML = '';
        Object.keys(grouped).sort().forEach(groupName => {
            this.tbody.appendChild(this.createGroupHeaderRow(groupName, grouped[groupName].length));
            if (!this.state.collapsedGroups.has(groupName)) {
                grouped[groupName].forEach(row => this.tbody.appendChild(this.createDataRow(row)));
            }
        });
    }

    renderServerGroupedBody(data) {
        this.tbody.innerHTML = '';
        data.forEach(group => {
            this.tbody.appendChild(this.createGroupHeaderRow(group.groupName, group.itemCount));
            if (!this.state.collapsedGroups.has(group.groupName)) {
                group.items.forEach(row => this.tbody.appendChild(this.createDataRow(row)));
            }
        });
    }

    // --- 6. UI & ELEMENT CREATION HELPERS ---
    createHeader() {
        this.thead.innerHTML = '';
        if (this.config.columnGroups && this.config.columnGroups.length > 0) {
            const groupRow = document.createElement('tr');
            if (this.config.enableCheckboxes) groupRow.appendChild(document.createElement('th'));
            this.config.columnGroups.forEach(group => {
                const th = document.createElement('th');
                th.textContent = group.label;
                th.colSpan = group.colspan;
                th.classList.add('group-header');
                groupRow.appendChild(th);
            });
            if (this.config.actions.length > 0) groupRow.appendChild(document.createElement('th'));
            this.thead.appendChild(groupRow);
        }
        const headerRow = document.createElement('tr');
        if (this.config.enableCheckboxes) {
            headerRow.appendChild(this.createCheckboxHeader());
        }
        this.config.columns.forEach(col => {
            headerRow.appendChild(this.createColumnHeader(col));
        });
        if (this.config.actions.length > 0) {
            const th = document.createElement('th');
            th.textContent = 'Actions';
            headerRow.appendChild(th);
        }
        this.thead.appendChild(headerRow);
        if (this.config.enableColumnFilter) {
            this.thead.appendChild(this.createFilterRow());
        }
    }

    createCheckboxHeader() {
        const th = document.createElement('th');
        th.classList.add('checkbox-cell');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.addEventListener('change', e => this.handleSelectAll(e));
        th.appendChild(checkbox);
        return th;
    }

    /**
     * Handles the click event for the 'Select All' checkbox in the header.
     * @param {Event} event - The change event from the header checkbox.
     */
    handleSelectAll(event) {
        const isChecked = event.target.checked;

        // Update all checkboxes in the current view
        this.tbody.querySelectorAll('.row-checkbox').forEach(checkbox => {
            checkbox.checked = isChecked;
        });

        // Trigger the onSelectAll callback, if it has been defined by the user
        if (typeof this.config.onSelectAll === 'function') {
            this.config.onSelectAll(isChecked, this.getSelectedRows());
        }
    }

    createColumnHeader(col) {
        const th = document.createElement('th');
        th.textContent = col.label;
        th.dataset.key = col.key;
        if (col.width) th.style.width = col.width;
        if (col.sortable) {
            th.classList.add('sortable');
            th.innerHTML += '<span class="sort-indicator"></span>';
            th.addEventListener('click', () => this.handleSort(col.key));
        }
        if (this.config.enableGrouping) {
            th.draggable = true;
            th.addEventListener('dragstart', e => {
                e.dataTransfer.setData('text/plain', col.key);
                e.target.classList.add('dragging');
            });
            th.addEventListener('dragend', e => e.target.classList.remove('dragging'));
        }
        if (this.config.enableColumnResize) {
            const resizeHandle = document.createElement('div');
            resizeHandle.classList.add('resize-handle');
            th.appendChild(resizeHandle);
            this.addResizeFunctionality(th, resizeHandle);
        }
        return th;
    }

    createFilterRow() {
        const filterRow = document.createElement('tr');
        if (this.config.enableCheckboxes) filterRow.appendChild(document.createElement('td'));
        this.config.columns.forEach(col => {
            const td = document.createElement('td');
            if (col.filterable) {
                const cell = document.createElement('div');
                cell.className = 'filter-cell';
                const icon = document.createElement('span');
                icon.className = 'filter-icon';
                icon.innerHTML = '&#9660;';
                icon.title = 'Change filter operator';
                icon.addEventListener('click', e => {
                    e.stopPropagation();
                    cell.classList.toggle('show-operator');
                });
                const operators = this.filterOperators[col.type] || this.filterOperators.default;
                const select = document.createElement('select');
                select.className = 'filter-operator';
                operators.forEach(op => {
                    const option = document.createElement('option');
                    option.value = op;
                    option.textContent = op;
                    select.appendChild(option);
                });
                select.addEventListener('click', e => e.stopPropagation());
                select.addEventListener('change', () => {
                    this.handleColumnFilterChange(col.key, 'operator', select.value);
                    cell.classList.remove('show-operator');
                });
                const input = document.createElement('input');
                input.type = col.type === 'number' ? 'number' : 'text';
                input.className = 'filter-input';
                input.placeholder = 'Filter...';
                input.addEventListener('keyup', () => this.handleColumnFilterChange(col.key, 'value', input.value));
                cell.appendChild(icon);
                cell.appendChild(input);
                cell.appendChild(select);
                td.appendChild(cell);
            }
            filterRow.appendChild(td);
        });
        if (this.config.actions.length > 0) filterRow.appendChild(document.createElement('td'));
        return filterRow;
    }

    createDataRow(row) {
        const tr = document.createElement('tr');
        tr.rowData = row; // Attach the row's data directly to the TR element

        if (this.config.enableCheckboxes) {
            const td = document.createElement('td');
            td.className = 'checkbox-cell';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'row-checkbox';
            checkbox.addEventListener('change', (e) => {
                if (typeof this.config.onCheckboxChange === 'function') {
                    this.config.onCheckboxChange(e.target.checked, row, this.getSelectedRows());
                }
            });
            td.appendChild(checkbox);
            tr.appendChild(td);
        }
        
        this.config.columns.forEach(col => {
            const td = document.createElement('td');
            const cellValue = row[col.key] !== null && row[col.key] !== undefined ? row[col.key] : '';
            td.textContent = cellValue;

            // --- NEW: Inline Editing Logic ---
            if (this.config.enableEditing && col.editable) {
                td.classList.add('editable-cell');
                td.dataset.columnKey = col.key; // Store column key for easier access

                td.addEventListener('click', () => {
                    if (!td.querySelector('input, select')) { // Prevent creating multiple inputs
                        this.enterEditMode(td, row, col);
                    }
                });
            }

            // --- NEW: CELL STYLER LOGIC ---
            if (typeof col.cellStyler === 'function') {
                const styles = col.cellStyler(cellValue, row);
                if (styles) {
                    if (styles.className) {
                        td.classList.add(...styles.className.split(' '));
                    }
                    if (styles.style && typeof styles.style === 'object') {
                        Object.assign(td.style, styles.style);
                    }
                }
            }
            tr.appendChild(td);
        });

        if (this.config.actions.length > 0) {
            tr.appendChild(this.createActionsCell(row));
        }
        
        // --- NEW: ROW STYLER LOGIC ---
        // This is called last so it can override cell styles if needed.
        if (typeof this.config.onRowCreate === 'function') {
            this.config.onRowCreate(row, tr);
        }
        
        return tr;
    }

    /**
     * Enters edit mode for a given table cell.
     * @param {HTMLElement} td - The table data cell (<td>) to make editable.
     * @param {Object} rowData - The data object for the current row.
     * @param {Object} columnConfig - The configuration object for the current column.
     */
    enterEditMode(td, rowData, columnConfig) {
        const originalValue = rowData[columnConfig.key];
        td.innerHTML = ''; // Clear cell content

        let inputElement;

        switch (columnConfig.editType) {
            case 'text':
            case 'number':
                inputElement = document.createElement('input');
                inputElement.type = columnConfig.editType;
                inputElement.value = originalValue;
                inputElement.classList.add('gdt-edit-input');
                break;
            case 'dropdown':
                inputElement = document.createElement('select');
                inputElement.classList.add('gdt-edit-input');
                columnConfig.editOptions.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option;
                    optionElement.textContent = option;
                    if (option === originalValue) {
                        optionElement.selected = true;
                    }
                    inputElement.appendChild(optionElement);
                });
                break;
            case 'checkbox':
                inputElement = document.createElement('input');
                inputElement.type = 'checkbox';
                inputElement.checked = !!originalValue; // Convert to boolean
                inputElement.classList.add('gdt-edit-checkbox');
                break;
            default:
                console.warn(`VikCraftDataTable: Unsupported editType "${columnConfig.editType}" for column "${columnConfig.key}"`);
                td.textContent = originalValue; // Revert to original
                return;
        }

        td.appendChild(inputElement);
        inputElement.focus();

        // Handle saving the new value
        const saveEdit = () => {
            let newValue;
            if (columnConfig.editType === 'checkbox') {
                newValue = inputElement.checked;
            } else if (columnConfig.editType === 'number') {
                newValue = parseFloat(inputElement.value);
                if (isNaN(newValue)) newValue = null; // Handle invalid number input
            } else {
                newValue = inputElement.value;
            }
            
            // Check if value actually changed
            if (newValue !== originalValue) {
                // Update the actual data source (this.config.data for client-side)
                // For server-side, you'd typically send this to an API.
                rowData[columnConfig.key] = newValue;
                
                // Call the user-defined callback for handling the edit
                if (typeof this.config.onCellEdit === 'function') {
                    this.config.onCellEdit(columnConfig.key, newValue, rowData);
                }
            }
            // Exit edit mode:
            td.textContent = newValue; // Update the cell's displayed text
            // If it's a checkbox, special handling to show the checkbox again, not just true/false text
            if (columnConfig.editType === 'checkbox') {
                td.innerHTML = ''; // Clear, then append the checkbox
                const displayCheckbox = document.createElement('input');
                displayCheckbox.type = 'checkbox';
                displayCheckbox.disabled = true; // Make it non-interactive in display mode
                displayCheckbox.checked = !!newValue;
                td.appendChild(displayCheckbox);
            }
        };

        // Event listeners for exiting edit mode
        if (columnConfig.editType === 'checkbox') {
            inputElement.addEventListener('change', saveEdit); // Checkboxes save on change
        } else {
            inputElement.addEventListener('blur', saveEdit); // Save on blur (lose focus)
            inputElement.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault(); // Prevent new line in textareas if applicable, though not for input/select
                    saveEdit();
                } else if (e.key === 'Escape') {
                    // Revert to original value and exit edit mode
                    td.textContent = originalValue;
                    // If it's a checkbox, revert its display too
                    if (columnConfig.editType === 'checkbox') {
                        td.innerHTML = '';
                        const displayCheckbox = document.createElement('input');
                        displayCheckbox.type = 'checkbox';
                        displayCheckbox.disabled = true;
                        displayCheckbox.checked = !!originalValue;
                        td.appendChild(displayCheckbox);
                    }
                }
            });
        }
    }
    
    createActionsCell(row) {
        const td = document.createElement('td');
        this.config.actions.forEach(action => {
            const button = document.createElement('button');
            button.textContent = action.label;
            button.className = `action-button ${action.className}`;
            button.addEventListener('click', () => action.onClick(row));
            td.appendChild(button);
        });
        return td;
    }

    createGroupHeaderRow(groupName, itemCount) {
        const tr = document.createElement('tr');
        tr.className = 'group-row';
        tr.addEventListener('click', () => this.toggleGroup(groupName));
        const td = document.createElement('td');
        const colSpan = this.config.columns.length + (this.config.enableCheckboxes ? 1 : 0) + (this.config.actions.length > 0 ? 1 : 0);
        td.colSpan = colSpan;
        const isCollapsed = this.state.collapsedGroups.has(groupName);
        td.innerHTML = `<span class="group-toggle-icon ${isCollapsed ? 'collapsed' : ''}">&#9660;</span> ${groupName} (${itemCount})`;
        tr.appendChild(td);
        return tr;
    }
    
    updateGroupByUI() {
        if (!this.state.groupBy) {
            this.groupByContainer.innerHTML = `<span class="group-by-placeholder">Drag a column here to group</span>`;
        } else {
            const column = this.config.columns.find(c => c.key === this.state.groupBy);
            this.groupByContainer.innerHTML = `<span class="group-by-tag">Grouped by: ${column.label} <span class="remove-group" title="Remove grouping">&times;</span></span>`;
            this.groupByContainer.querySelector('.remove-group').addEventListener('click', () => this.setGroupBy(null));
        }
    }

    addResizeFunctionality(th, handle) {
        handle.addEventListener('mousedown', e => {
            e.preventDefault();
            const startX = e.clientX;
            const startWidth = th.offsetWidth;
            const onMouseMove = moveEvent => {
                const newWidth = startWidth + (moveEvent.clientX - startX);
                if (newWidth > 50) {
                    th.style.width = `${newWidth}px`;
                }
            };
            const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
    }

    renderPagination(totalRows) {
        if (!this.config.enablePagination) return;
        const totalPages = Math.ceil(totalRows / this.state.rowsPerPage);
        const startRow = totalRows === 0 ? 0 : (this.state.currentPage - 1) * this.state.rowsPerPage + 1;
        const endRow = Math.min(startRow + this.state.rowsPerPage - 1, totalRows);
        this.paginationInfoDiv.textContent = `Showing ${startRow} to ${endRow} of ${totalRows} entries`;
        this.paginationButtonsDiv.innerHTML = '';
        if (totalPages <= 1) return;
        
        const createButton = (text, page, disabled) => {
            const button = document.createElement('button');
            button.textContent = text;
            button.disabled = disabled;
            if (this.state.currentPage === page) button.classList.add('active');
            button.addEventListener('click', () => {
                this.state.currentPage = page;
                if (this.config.serverSide) this.fetchData(); else this.render();
            });
            return button;
        };

        this.paginationButtonsDiv.appendChild(createButton('«', 1, this.state.currentPage === 1));
        this.paginationButtonsDiv.appendChild(createButton('‹', this.state.currentPage - 1, this.state.currentPage === 1));
        this.paginationButtonsDiv.append(` Page ${this.state.currentPage} of ${totalPages} `);
        this.paginationButtonsDiv.appendChild(createButton('›', this.state.currentPage + 1, this.state.currentPage === totalPages));
        this.paginationButtonsDiv.appendChild(createButton('»', totalPages, this.state.currentPage === totalPages));
    }
    
    setTheme(themeName) {
        this.container.classList.remove('theme-dark', 'theme-narrow');
        if (themeName === 'dark' || themeName === 'narrow') {
            this.container.classList.add(`theme-${themeName}`);
        }
        this.config.theme = themeName;
    }

    /**
     * Returns an array of the data objects for all currently selected rows.
     * @returns {Array<Object>}
     */
    getSelectedRows() {
        const selectedRows = [];
        this.tbody.querySelectorAll('.row-checkbox:checked').forEach(checkbox => {
            // Find the parent <tr> and get its associated data
            const tr = checkbox.closest('tr');
            if (tr && tr.rowData) {
                selectedRows.push(tr.rowData);
            }
        });
        return selectedRows;
    }

    /**
     * --- NEW: EXCEL EXPORT LOGIC ---
     * Gathers the current data (filtered and sorted) and exports it as an XLSX file.
     */
    /**
     * --- NEW: EXCEL EXPORT LOGIC (Corrected for Server-Side) ---
     * Gathers the current data (filtered and sorted) and exports it as an XLSX file.
     */
    exportToExcel() {
        console.log("Starting Excel export...");

        let dataToExport;

        if (this.config.serverSide) {
            // For server-side, we can only export the currently visible data.
            // A full export would require a separate backend endpoint.
            alert("For server-side tables, only the currently visible data will be exported.");

            // --- THIS IS THE CORRECTED LOGIC ---
            // OLD (BUGGY) LINE:
            // dataToExport = this.getSelectedRows().length > 0 ? this.getSelectedRows() : Array.from(this.tbody.querySelectorAll('tr[rowData]')).map(tr => tr.rowData);
            
            // NEW (CORRECTED) LINE:
            dataToExport = Array.from(this.tbody.querySelectorAll('tr'))
                                .filter(tr => tr.rowData) // Filter for rows that have the data property
                                .map(tr => tr.rowData);   // Get the data from the property

            // If the user has selected specific rows, prioritize those.
            const selectedRows = this.getSelectedRows();
            if (selectedRows.length > 0) {
                dataToExport = selectedRows;
            }
            
        } else {
            // For client-side, export all data that matches the current filters.
            dataToExport = this.getProcessedData();
        }

        if (dataToExport.length === 0) {
            alert("No data to export.");
            return;
        }

        const conf = this.config.excelExportConfig;
        const finalData = [];

        // 1. Add Title and Subtitle
        finalData.push([conf.title]);
        finalData.push([conf.subtitle]);
        finalData.push([]); // Add a blank row for spacing

        // 2. Add Headers
        const headers = this.config.columns.map(col => col.label);
        finalData.push(headers);

        // 3. Add Data Rows
        dataToExport.forEach(row => {
            const rowData = this.config.columns.map(col => row[col.key] ?? ''); // Use ?? for null/undefined
            finalData.push(rowData);
        });

        // 4. Create Worksheet and Workbook using SheetJS
        const ws = XLSX.utils.aoa_to_sheet(finalData);

        // 5. Merge cells for Title and Subtitle
        const merge = [
            { s: { r: 0, c: 0 }, e: { r: 0, c: headers.length - 1 } }, // Title
            { s: { r: 1, c: 0 }, e: { r: 1, c: headers.length - 1 } }  // Subtitle
        ];
        ws['!merges'] = merge;
        
        // Optional: Set column widths
        const colWidths = headers.map(h => ({ wch: Math.max(h.length, 15) }));
        ws['!cols'] = colWidths;

        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'Report');

        // 6. Trigger Download
        XLSX.writeFile(wb, conf.filename);
        console.log("Excel export complete.");
    }

    /**
     * --- NEW PUBLIC METHOD ---
     * Reloads the table with new or updated custom filters.
     * Resets pagination to the first page.
     * @param {Object} newFilters - An object of key-value pairs to add to customFilters.
     */
    reloadData(newFilters = {}) {
        // Merge the new filters into the existing customFilters config
        // This allows you to update one filter without affecting others.
        Object.assign(this.config.customFilters, newFilters);

        // CRITICAL: Reset to page 1 whenever filters change
        this.state.currentPage = 1;

        // Trigger the data fetch, which will use the updated customFilters
        if (this.config.serverSide) {
            this.fetchData();
        } else {
            this.render(); // For client-side rendering
        }
        console.log('Table reloaded with filters:', this.config.customFilters);
    }
    
}